"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("reshow-runtime/helpers/extends"));

var _path = _interopRequireDefault(require("path"));

var _resolve = _interopRequireDefault(require("resolve"));

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperModuleImports = require("@babel/helper-module-imports");

var _core = require("@babel/core");

var _definitions = _interopRequireDefault(require("./definitions"));

function resolveAbsoluteRuntime(moduleName, dirname) {
  try {
    return _path["default"].dirname(_resolve["default"].sync(moduleName + "/package.json", {
      basedir: dirname
    }));
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    throw (0, _extends2["default"])(new Error("Failed to resolve \"" + moduleName + "\" relative to \"" + dirname + "\""), {
      code: "BABEL_RUNTIME_NOT_FOUND",
      runtime: moduleName,
      dirname: dirname
    });
  }
}

function supportsStaticESM(caller) {
  return !!(caller && caller.supportsStaticESM);
}

var _default = (0, _helperPluginUtils.declare)(function (api, options, dirname) {
  api.assertVersion(7);
  var _options$corejs = options.corejs,
      corejsVersion = _options$corejs === void 0 ? false : _options$corejs,
      _options$helpers = options.helpers,
      useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
      _options$regenerator = options.regenerator,
      useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
      _options$useESModules = options.useESModules,
      useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
      _options$version = options.version,
      runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
      _options$absoluteRunt = options.absoluteRuntime,
      absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
  var definitions = (0, _definitions["default"])(runtimeVersion);

  if (typeof useRuntimeRegenerator !== "boolean") {
    throw new Error("The 'regenerator' option must be undefined, or a boolean.");
  }

  if (typeof useRuntimeHelpers !== "boolean") {
    throw new Error("The 'helpers' option must be undefined, or a boolean.");
  }

  if (typeof useESModules !== "boolean" && useESModules !== "auto") {
    throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
  }

  if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
    throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
  }

  if (corejsVersion !== false && (typeof corejsVersion !== "number" || corejsVersion !== 2) && (typeof corejsVersion !== "string" || corejsVersion !== "2")) {
    throw new Error("The 'corejs' option must be undefined, false, 2 or '2', " + ("but got " + JSON.stringify(corejsVersion) + "."));
  }

  if (typeof runtimeVersion !== "string") {
    throw new Error("The 'version' option must be a version string.");
  }

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  if (has(options, "useBuiltIns")) {
    if (options.useBuiltIns) {
      throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
    } else {
      throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.");
    }
  }

  if (has(options, "polyfill")) {
    if (options.polyfill === false) {
      throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
    } else {
      throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.");
    }
  }

  if (has(options, "moduleName")) {
    throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
  }

  var esModules = useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
  var injectCoreJS2 = "" + corejsVersion === "2";
  var moduleName = injectCoreJS2 ? "@babel/runtime-corejs2" : "reshow-runtime";
  var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
  var modulePath = moduleName;

  if (absoluteRuntime !== false) {
    modulePath = resolveAbsoluteRuntime(moduleName, _path["default"].resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
  }

  return {
    pre: function pre(file) {
      var _this = this;

      if (useRuntimeHelpers) {
        file.set("helperGenerator", function (name) {
          // If the helper didn't exist yet at the version given, we bail
          // out and let Babel either insert it directly, or throw an error
          // so that plugins can handle that case properly.
          if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
            return;
          }

          var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1; // Explicitly set the CommonJS interop helpers to their reserve
          // blockHoist of 4 so they are guaranteed to exist
          // when other things used them to import.

          var blockHoist = isInteropHelper && !(0, _helperModuleImports.isModule)(file.path) ? 4 : undefined;
          var helpersDir = esModules && file.path.node.sourceType === "module" ? "es/helpers" : "helpers";
          return _this.addDefaultImport(modulePath + "/" + helpersDir + "/" + name, name, blockHoist);
        });
      }

      var cache = new Map();

      this.addDefaultImport = function (source, nameHint, blockHoist) {
        // If something on the page adds a helper when the file is an ES6
        // file, we can't reused the cached helper name after things have been
        // transformed because it has almost certainly been renamed.
        var cacheKey = (0, _helperModuleImports.isModule)(file.path);
        var key = source + ":" + nameHint + ":" + (cacheKey || "");
        var cached = cache.get(key);

        if (cached) {
          cached = _core.types.cloneNode(cached);
        } else {
          cached = (0, _helperModuleImports.addDefault)(file.path, source, {
            importedInterop: "uncompiled",
            nameHint: nameHint,
            blockHoist: blockHoist
          });
          cache.set(key, cached);
        }

        return cached;
      };
    },
    visitor: {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var node = path.node,
            parent = path.parent,
            scope = path.scope;

        if (node.name === "regeneratorRuntime" && useRuntimeRegenerator) {
          path.replaceWith(this.addDefaultImport(modulePath + "/regenerator", "regeneratorRuntime"));
          return;
        }

        if (!injectCoreJS2) return;
        if (_core.types.isMemberExpression(parent)) return;
        if (!has(definitions.builtins, node.name)) return;
        if (scope.getBindingIdentifier(node.name)) return; // Symbol() -> _core.Symbol(); new Promise -> new _core.Promise

        path.replaceWith(this.addDefaultImport(modulePath + "/core-js/" + definitions.builtins[node.name], node.name));
      },
      // arr[Symbol.iterator]() -> _core.$for.getIterator(arr)
      CallExpression: function CallExpression(path) {
        if (!injectCoreJS2) return; // we can't compile this

        if (path.node.arguments.length) return;
        var callee = path.node.callee;
        if (!_core.types.isMemberExpression(callee)) return;
        if (!callee.computed) return;

        if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
          return;
        }

        path.replaceWith(_core.types.callExpression(this.addDefaultImport(modulePath + "/core-js/get-iterator", "getIterator"), [callee.object]));
      },
      // Symbol.iterator in arr -> core.$for.isIterable(arr)
      BinaryExpression: function BinaryExpression(path) {
        if (!injectCoreJS2) return;
        if (path.node.operator !== "in") return;
        if (!path.get("left").matchesPattern("Symbol.iterator")) return;
        path.replaceWith(_core.types.callExpression(this.addDefaultImport(modulePath + "/core-js/is-iterable", "isIterable"), [path.node.right]));
      },
      // Array.from -> _core.Array.from
      MemberExpression: {
        enter: function enter(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          var node = path.node;
          var obj = node.object;
          var prop = node.property;
          if (!_core.types.isReferenced(obj, node)) return;
          if (node.computed) return;
          if (!has(definitions.methods, obj.name)) return;
          var methods = definitions.methods[obj.name];
          if (!has(methods, prop.name)) return; // doesn't reference the global

          if (path.scope.getBindingIdentifier(obj.name)) return; // special case Object.defineProperty to not use core-js when using string keys

          if (obj.name === "Object" && prop.name === "defineProperty" && path.parentPath.isCallExpression()) {
            var call = path.parentPath.node;

            if (call.arguments.length === 3 && _core.types.isLiteral(call.arguments[1])) {
              return;
            }
          }

          path.replaceWith(this.addDefaultImport(modulePath + "/core-js/" + methods[prop.name], obj.name + "$" + prop.name));
        },
        exit: function exit(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          var node = path.node;
          var obj = node.object;
          if (!has(definitions.builtins, obj.name)) return;
          if (path.scope.getBindingIdentifier(obj.name)) return;
          path.replaceWith(_core.types.memberExpression(this.addDefaultImport(modulePath + "/core-js/" + definitions.builtins[obj.name], obj.name), node.property, node.computed));
        }
      }
    }
  };
});

exports["default"] = _default;
module.exports = exports.default;