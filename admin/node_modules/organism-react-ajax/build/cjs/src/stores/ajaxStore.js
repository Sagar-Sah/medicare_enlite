"use strict";

var _interopRequireWildcard3 = require("reshow-runtime/helpers/interopRequireWildcard");
var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.initAjaxWorkerEvent = exports.hasUrl = exports.getRawUrl = exports["default"] = exports.ajaxDispatch = void 0;
var _classCallCheck2 = _interopRequireDefault(require("reshow-runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("reshow-runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("reshow-runtime/helpers/defineProperty"));
var _interopRequireWildcard2 = _interopRequireDefault(require("reshow-runtime/helpers/interopRequireWildcard"));
var _objectSpread2 = _interopRequireDefault(require("reshow-runtime/helpers/objectSpread2"));
var _reshowFlux = require("reshow-flux");
var _getObjectValue = _interopRequireWildcard3(require("get-object-value"));
var _setObjectValue = _interopRequireDefault(require("set-object-value"));
var _smoothScrollTo = _interopRequireDefault(require("smooth-scroll-to"));
var _getRandomId = _interopRequireWildcard3(require("get-random-id"));
var _callFunc = _interopRequireDefault(require("call-func"));
var _reshowConstant = require("reshow-constant");
// @ts-check

var empty = function empty() {};
var Callbacks = [];
var wsAuth = (0, _reshowFlux.Map)();
var gWorker;
var fakeWorker = false;
var isWorkerReady;
var hasUrl = function hasUrl(s) {
  return s && "#" !== s && "?" !== s;
};
exports.hasUrl = hasUrl;
var initAjaxWorkerEvent = function initAjaxWorkerEvent(worker) {
  worker.addEventListener("message", function (e) {
    var sourceType = (0, _getObjectValue["default"])(e, ["data", "type"]);
    switch (sourceType) {
      case "ready":
        // fakeWorker will not run this
        gWorker = worker;
        isWorkerReady = true;
        break;
      default:
        var nextState = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, e.data), {}, {
          sourceType: sourceType,
          type: "callback"
        });
        ajaxDispatch(nextState);
        break;
    }
  });
};
exports.initAjaxWorkerEvent = initAjaxWorkerEvent;
var initFakeWorker = function initFakeWorker(cb) {
  Promise.resolve().then(function () {
    return (0, _interopRequireWildcard2["default"])(require("../worker.js"));
  }).then(function (workerObject) {
    fakeWorker = (0, _getObjectValue.getDefault)(workerObject);
    initAjaxWorkerEvent(fakeWorker);
    if (!gWorker) {
      gWorker = fakeWorker;
    }
    isWorkerReady = true;
    cb();
  });
};
var handleUseNewUrl = function handleUseNewUrl(state, action, url) {
  var prevUrl = state.get("currentLocation");
  if (prevUrl !== url) {
    var onUrlChange = state.get("onUrlChange");
    state = (0, _reshowFlux.mergeMap)(state["delete"]("themePath").set("currentLocation", url), (0, _callFunc["default"])(onUrlChange, [url, {
      state: state,
      action: action
    }]));
  }
  return state;
};
var getCallback = function getCallback(state, action, json, response) {
  var params = (0, _getObjectValue["default"])(action, ["params"], {});
  var callback;
  if ((0, _getObjectValue["default"])(json, ["data", "errors"]) || !(0, _getObjectValue["default"])(response, ["ok"])) {
    if (params.errorCallback) {
      callback = Callbacks[params.errorCallback];
      delete Callbacks[params.errorCallback];
    }
  }
  var debugs = json.debugs;
  if (debugs) {
    var bFail = false;
    Promise.resolve().then(function () {
      return (0, _interopRequireWildcard2["default"])(require("../lib/dlog.js"));
    }).then(function (dlog) {
      var DLOG = (0, _getObjectValue.getDefault)(dlog);
      var oLog = new DLOG({
        level: "trace"
      });
      debugs.forEach(function (v) {
        var dump = (0, _getObjectValue["default"])(oLog, [v[0]], function () {
          return oLog.info;
        });
        dump.call(oLog, v[1]);
      });
    });
    debugs.forEach(function (v) {
      if ("error" === v[1]) {
        bFail = true;
      }
    });
    if (bFail) {
      return empty;
    }
  }
  if (!callback) {
    if (params.callback) {
      callback = Callbacks[params.callback];
      delete Callbacks[params.callback];
    } else {
      callback = state.get("callback");
    }
  }
  return callback;
};
var getRawUrl = function getRawUrl(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    _ref$url = _ref.url,
    url = _ref$url === void 0 ? null : _ref$url,
    _ref$path = _ref.path,
    path = _ref$path === void 0 ? null : _ref$path,
    _ref$baseUrl = _ref.baseUrl,
    baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl;
  if (!hasUrl(url)) {
    if (path) {
      baseUrl = baseUrl || store.getState().get("baseUrl") || "";
      url = baseUrl + path;
    } else {
      url = "#";
    }
  }
  return url;
};
exports.getRawUrl = getRawUrl;
var cookAjaxUrl = function cookAjaxUrl(params, ajaxUrl, globalHeaders) {
  if (globalHeaders && !(0, _getObjectValue["default"])(params, ["ignoreGlobalHeaders"])) {
    if (globalHeaders.toJS) {
      params.globalHeaders = globalHeaders.toJS();
    } else {
      console.error("Global headers should be a map.", globalHeaders);
    }
  }
  var urls = ajaxUrl.split("#");
  var query = (0, _getObjectValue["default"])(params, ["query"], {});
  if (urls[1]) {
    query["--hashState"] = urls[1];
  }

  // <!-- Clean key for fixed superagent error
  if (query) {
    (0, _reshowConstant.KEYS)(query).forEach(function (key) {
      if ("undefined" === typeof query[key]) {
        delete query[key];
      }
    });
    params.query = query;
  }
  // -->

  return urls[0];
};
var handleAjax = /*#__PURE__*/function () {
  function handleAjax() {
    (0, _classCallCheck2["default"])(this, handleAjax);
    (0, _defineProperty2["default"])(this, "queue", []);
  }
  (0, _createClass2["default"])(handleAjax, [{
    key: "worker",
    value: function worker(data) {
      var _this = this;
      if (isWorkerReady && fakeWorker) {
        var disableWebWorker = (0, _getObjectValue["default"])(data, ["action", "params", "disableWebWorker"]);
        var run = disableWebWorker ? fakeWorker : gWorker;
        run.postMessage(data);
      } else {
        if (false === fakeWorker) {
          initFakeWorker(function () {
            _this.queue.forEach(function (d) {
              return _this.worker(d);
            });
          });
          fakeWorker = null;
        }
        this.queue.push(data);
      }
    }
  }, {
    key: "start",
    value: function start(state) {
      return state.set("isRunning", 1);
    }
  }, {
    key: "done",
    value: function done() {
      // update progress should run very end.
      setTimeout(function () {
        return ajaxDispatch({
          isRunning: 0
        });
      }, 500);
    }
  }, {
    key: "storeCallback",
    value: function storeCallback(action) {
      var cb = (0, _getObjectValue["default"])(action, ["params", "callback"]);
      if (cb) {
        var cbKey = (0, _getRandomId.getSN)("cb");
        Callbacks[cbKey] = cb;
        action.params.callback = cbKey;
      }
      var err = (0, _getObjectValue["default"])(action, ["params", "errorCallback"]);
      if (err) {
        var errCbKey = (0, _getRandomId.getSN)("err");
        Callbacks[errCbKey] = err;
        action.params.errorCallback = errCbKey;
      }
      var wcb = (0, _getObjectValue["default"])(action, ["params", "workerCallback"]);
      if (wcb) {
        action.params.workerCallback = wcb + "";
      }
      return action;
    }
  }, {
    key: "setWsAuth",
    value: function setWsAuth(key, data) {
      wsAuth = wsAuth.set(key, data);
    }
  }, {
    key: "getWsAuth",
    value: function getWsAuth(key) {
      if (!key) {
        return wsAuth.toJS();
      } else {
        return wsAuth.get(key).toJS();
      }
    }
  }, {
    key: "initWs",
    value: function initWs(state, action) {
      var params = (0, _getObjectValue["default"])(action, ["params"], {});
      var url = params.url;
      if (url) {
        this.worker({
          params: params,
          ws: url,
          type: "initWs"
        });
      }
      return state;
    }
  }, {
    key: "closeWs",
    value: function closeWs(state, action) {
      var url = (0, _getObjectValue["default"])(action, ["params", "url"]);
      if (url) {
        this.worker({
          ws: url,
          type: "closeWs"
        });
      }
      return state;
    }
  }, {
    key: "ajaxGet",
    value: function ajaxGet(state, action) {
      var params = action.params;
      var rawUrl = getRawUrl(params);
      if (params.updateUrl && store.urlDispatch && rawUrl !== document.URL) {
        store.urlDispatch({
          type: "url",
          url: rawUrl
        });
      }
      if (params.disableAjax) {
        return this.applyCallback(state, {
          params: {
            json: handleUseNewUrl(state, action, rawUrl),
            disableAjax: params.disableAjax,
            scrollBack: params.scrollBack
          }
        });
      }
      if (!params.disableProgress) {
        state = this.start(state);
      }
      var ajaxUrl = cookAjaxUrl(params, rawUrl, state.get("globalHeaders"));
      if (!params.query) {
        params.query = {};
      }
      if (!params.disableCacheBusting) {
        params.query["--r"] = params.randomCacheBusting ? (0, _getRandomId["default"])() : Math.floor((0, _getRandomId.getTimestamp)() / 60000);
      } else {
        params.query["--r"] = state.get("staticVersion");
      }
      this.worker({
        type: "ajaxGet",
        url: ajaxUrl,
        action: this.storeCallback(action)
      });
      return state;
    }
  }, {
    key: "ajaxPost",
    value: function ajaxPost(state, action) {
      var params = action.params;
      if (!params.disableProgress) {
        state = this.start(state);
      }
      var rawUrl = getRawUrl(params);
      var ajaxUrl = cookAjaxUrl(params, rawUrl, state.get("globalHeaders"));
      this.worker({
        type: "ajaxPost",
        url: ajaxUrl,
        action: this.storeCallback(action)
      });
      return state;
    }
  }, {
    key: "applyCallback",
    value: function applyCallback(state, action) {
      var sourceType = (0, _getObjectValue["default"])(action, ["sourceType"]);
      var params = (0, _getObjectValue["default"])(action, ["params"], {});
      if (!params.disableProgress) {
        this.done();
      }
      var response = (0, _getObjectValue["default"])(params, ["response"]);
      var text = (0, _getObjectValue["default"])(params, ["text"]);
      var json = (0, _getObjectValue["default"])(params, ["json"], {});
      var callback = getCallback(state, action, json, response);
      var url = (0, _getObjectValue["default"])(params, ["url"]);
      var isRedirect = null;
      switch (json.type) {
        case "ws-auth":
          this.setWsAuth(url, json);
          break;
        default:
          if ("ws" === sourceType) {
            json[_reshowConstant.REAL_TIME_URL] = url;
            json[_reshowConstant.REAL_TIME_DATA_KEY] = json;
          }
          isRedirect = (0, _callFunc["default"])(callback, [json, text, response]);
          break;
      }
      if (false !== isRedirect) {
        var loc = json.clientRedirectTo;
        if (loc) {
          switch (json.clientRedirectType) {
            case "href":
              location.href = loc;
              break;
            case "replace":
            default:
              location.replace(loc);
              break;
          }
        }
      }
      if (params.disableAjax && false !== params.scrollBack || params.updateUrl && false !== params.scrollBack || params.scrollBack) {
        (0, _smoothScrollTo["default"])(0);
      }
      return state.set("currentLocation", json.currentLocation);
    }
  }, {
    key: "handleUrlChange",
    value: function handleUrlChange(state, action) {
      var url = (0, _getObjectValue["default"])(action, ["params", "url"], document.URL);
      /**
       * "!! Important !!" don't modify states of toggleBfChange and bfApplyUrl in other way,
       * such as ajaxGet.
       * Because this state should only trigger with bfchange.
       */
      return this.applyCallback(state.set("toggleBfChange", !state.get("toggleBfChange")).set("bfApplyUrl", url), {
        params: {
          json: handleUseNewUrl(state, action, url)
        }
      });
    }
  }]);
  return handleAjax;
}();
var oAjax = new handleAjax();

/**
 * @typedef {object} StateType
 * @property {function} get
 * @property {function} set
 */

/**
 * @typedef {StateType|Object} MaybeMapType
 */

/**
 * @typedef {Object} AjaxStore
 * @property {function} urlDispatch
 */

/**
 * @callback ReducerType
 * @param {StateType} state
 * @param {MaybeMapType} action
 * @returns {StateType}
 */

/**
 * @param {ReducerType} reduce
 * @param {MaybeMapType|function} initState
 * @returns {[store & AjaxStore, dispatch]}
 */
var AjaxStore = function AjaxStore(reduce, initState) {
  var _ImmutableStore = (0, _reshowFlux.ImmutableStore)(reduce, initState),
    store = _ImmutableStore[0],
    dispatch = _ImmutableStore[1];
  return [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, store), {}, {
    urlDispatch: function urlDispatch() {}
  }), dispatch];
};
var _AjaxStore = AjaxStore(function (state, action) {
    var type = action.type;
    switch (type) {
      case "ws/init":
        return oAjax.initWs(state, action);
      case "ws/close":
        return oAjax.closeWs(state, action);
      case "ajaxGet":
        return oAjax.ajaxGet(state, action);
      case "ajaxDelete":
      case "ajaxHead":
      case "ajaxPatch":
      case "ajaxPut":
        (0, _setObjectValue["default"])(action, ["params", "method"], type.substr(4).toLowerCase());
      case "ajaxPost":
        return oAjax.ajaxPost(state, action);
      case "urlChange":
        return oAjax.handleUrlChange(state, action);
      case "callback":
        return oAjax.applyCallback(state, action);
      default:
        if ((0, _reshowConstant.KEYS)(action).length) {
          return (0, _reshowFlux.mergeMap)(state, action);
        } else {
          return state;
        }
    }
  }, function () {
    var onUrlChange = function onUrlChange(url) {
      ajaxDispatch({
        type: "ajaxGet",
        params: {
          url: url,
          scrollBack: true
        }
      });
    };
    return (0, _reshowFlux.Map)({
      onUrlChange: onUrlChange
    });
  }),
  store = _AjaxStore[0],
  ajaxDispatch = _AjaxStore[1];
exports.ajaxDispatch = ajaxDispatch;
var _default = store;
exports["default"] = _default;