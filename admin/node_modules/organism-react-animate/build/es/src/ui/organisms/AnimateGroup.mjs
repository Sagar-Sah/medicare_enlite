import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _objectWithoutProperties from "reshow-runtime/es/helpers/objectWithoutProperties";
var _excluded = ["copyEnterToAppear", "isLoad", "statusKey", "component", "lazy", "children", "className", "onExited"];
import { useState, useEffect, useMemo } from "react";
import { build, mixClass, useLazyInject, getChildMapping, SemanticUI } from "react-atomic-molecule";
import get from "get-object-value";
import callfunc from "call-func";
import { useMounted } from "reshow-hooks";
import { KEYS } from "reshow-constant";
import CSSTransition from "../organisms/CSSTransition.mjs";
import { dataStatusKey, animateGroupClass } from "../../const.mjs";
import { InjectStyles } from "../../initAniStyle.mjs";
var injects = {};

var getAniProps = function getAniProps(props, copyEnterToAppear) {
  var {
    statusKey,
    timeout,
    delay,
    classNames,
    enter,
    exit,
    addEndListener,
    onEnter,
    onEntering,
    onEntered,
    onExit,
    onExiting
  } = props;
  var appear = props.appear;

  if (copyEnterToAppear && classNames && classNames.enter) {
    classNames.appear = classNames.enter;
    delay.appear = delay.enter;
    timeout.appear = timeout.enter;
    appear = true;
  }
  /* not assign onExited, because call at handleExited */


  var aniProps = {
    statusKey,
    timeout,
    delay,
    classNames,
    appear,
    enter,
    exit,
    addEndListener,
    onEnter,
    onEntering,
    onEntered,
    onExit,
    onExiting,
    in: true
  };
  return aniProps;
};

var buildCSSTransition = build(CSSTransition);

var AnimateGroup = function AnimateGroup(props) {
  var {
    copyEnterToAppear = true,
    isLoad = true,
    statusKey = dataStatusKey,
    component = SemanticUI,
    lazy = 150,
    children: propsChildren,
    className,
    onExited
  } = props,
      restProps = _objectWithoutProperties(props, _excluded);

  var [children, setChildren] = useState();

  var _mount = useMounted();

  injects[statusKey] = useLazyInject(InjectStyles({
    statusKey
  }), injects[statusKey]);
  var aniProps = getAniProps(restProps, copyEnterToAppear);
  KEYS(aniProps).forEach(function (key) {
    return delete restProps[key];
  });
  useEffect(function () {
    var _exitTimeout;

    var _enterTimeout;

    if (isLoad) {
      var handleExited = function handleExited(child) {
        return function (node) {
          callfunc(onExited, [node]);
          _exitTimeout = setTimeout(function () {
            if (false !== _mount()) {
              setChildren(function (children) {
                delete children[child.key];
                return _objectSpread({}, children);
              });
            }
          });
        };
      };

      var prevChildMapping = children || {};
      var nextChildMapping = getChildMapping(propsChildren, function (child, key) {
        return buildCSSTransition(_objectSpread(_objectSpread({}, aniProps), {}, {
          key: get(child, ["props", "name"], key),
          onExited: handleExited(child)
        }), child);
      });

      var allChildMapping = _objectSpread(_objectSpread({}, prevChildMapping), nextChildMapping);

      KEYS(allChildMapping).forEach(function (key) {
        var child = allChildMapping[key];
        var hasPrev = (key in prevChildMapping);
        var hasNext = (key in nextChildMapping);
        var prevChild = prevChildMapping[key];
        var isLeaving = !get(prevChild, ["props", "in"]);

        if (!hasNext && hasPrev) {
          // Will Exit
          if (!isLeaving) {
            allChildMapping[key] = build(child)({
              in: false
            });
          }
        }
      });

      if (!children) {
        _enterTimeout = setTimeout(function () {
          return setChildren(allChildMapping);
        }, lazy);
      } else {
        setChildren(allChildMapping);
      }
    }

    return function () {
      clearTimeout(_exitTimeout);
      clearTimeout(_enterTimeout);
    };
  }, [props.children, isLoad]);
  return useMemo(function () {
    if (!isLoad) {
      return build(component)(restProps);
    }
    /**
     * Should not setup style={overflow:hidden} here,
     *
     * for reduce animation effect.
     * you could assign it by yourself.
     */


    restProps.className = mixClass(className, animateGroupClass);
    return build(component)(restProps, KEYS(children || {}).map(function (key) {
      return children[key];
    }));
  }, [children, isLoad]);
};

export default AnimateGroup;