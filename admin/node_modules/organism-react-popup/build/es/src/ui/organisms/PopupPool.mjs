import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _objectWithoutProperties from "reshow-runtime/es/helpers/objectWithoutProperties";
var _excluded = ["component", "name"];
// @ts-check
import { useEffect, useMemo } from "react";
import { build, mixClass, SemanticUI } from "react-atomic-molecule";
import { useReturn, usePartialRender } from "reshow-return";
import { equal } from "reshow-flux";
import popupStore, { SHOW_NEXT, NODE_KEY } from "../../stores/popupStore.mjs";
/**
 * @param {Immutable.Map} nodes
 * @param {string} name
 * @returns {Immutable.Map}
 */

var getPops = function getPops(nodes, name) {
  var pops = nodes;
  nodes.forEach(function (v, k) {
    var _v$props;

    var toPool = (_v$props = v.props) === null || _v$props === void 0 ? void 0 : _v$props.toPool;

    if ((name || toPool) && toPool !== name) {
      pops = pops.delete(k);
    }
  });
  return pops;
};

var PopupPool = function PopupPool(_ref) {
  var {
    component = SemanticUI,
    name = null
  } = _ref,
      restProps = _objectWithoutProperties(_ref, _excluded);

  var [renderComponent, partialRender, setRenderKeys] = usePartialRender();
  var state = useReturn([NODE_KEY, SHOW_NEXT], popupStore);
  useEffect(function () {
    var nextPopNodes = getPops(state[NODE_KEY], name);
    var popsKeys = nextPopNodes.keySeq();
    setRenderKeys(
    /**
     * @param {Array} prev
     */
    function (prev) {
      return !equal(prev, popsKeys) ? popsKeys : prev;
    });
    var updateKey = state[SHOW_NEXT];

    if (nextPopNodes.has(updateKey)) {
      partialRender({
        [updateKey]: nextPopNodes.get(updateKey)
      });
    }
  }, [state[NODE_KEY]]);
  return useMemo(function () {
    return build(component)(_objectSpread(_objectSpread({}, restProps), {}, {
      name,
      className: mixClass(name, "popup-pool"),
      ui: false
    }), renderComponent);
  }, [renderComponent]);
};

export default PopupPool;