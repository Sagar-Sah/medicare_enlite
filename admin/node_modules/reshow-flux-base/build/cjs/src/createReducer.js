"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.refineAction = exports["default"] = void 0;
var _callFunc = _interopRequireDefault(require("call-func"));
var _reshowConstant = require("reshow-constant");
// @ts-check

/**
 * @typedef {object} emiter
 * @property {function} reset
 * @property {function} add
 * @property {function} remove
 * @property {function} emit
 */

/**
 * @template T
 * @typedef {T} state
 */

/**
 * @returns emiter
 */
var getMitt = function getMitt() {
  var pool = [];
  return {
    /**
     * @returns {array}
     */
    reset: function reset() {
      return pool.splice(0, pool.length);
    },
    /**
     * @param {function} handler
     * @returns {number}
     */
    add: function add(handler) {
      return pool.unshift(handler);
    },
    /**
     * >>> 0 for change indexOf return -1 to 4294967295
     * @param {function} handler
     * @returns {array}
     */
    remove: function remove(handler) {
      return pool.splice(pool.indexOf(handler) >>> 0, 1);
    },
    /**
     * @template T
     * @param {state<T>} state
     * @param {object} action
     * @param {state<T>} prevState
     */
    emit: function emit(state, action, prevState) {
      var nextExec = pool.slice(0); //https://github.com/react-atomic/reshow/issues/96
      setTimeout(function () {
        var i = nextExec.length;
        while (i--) {
          nextExec[i](state, action, prevState);
        }
      });
    }
  };
};

/**
 * Transpile dispatch("your-action-type", {foo: "bar"})
 * to dispatch({type: "your-action-type", params: {foo: "bar"}})
 *
 * @template T
 * @param {string|object|function} action
 * @param {object} params
 * @param {state<T>} prevState
 * @returns {object} lazy actions
 */
var refineAction = function refineAction(action, params, prevState) {
  if (params === void 0) {
    params = _reshowConstant.T_UNDEFINED;
  }
  if (prevState === void 0) {
    prevState = _reshowConstant.T_UNDEFINED;
  }
  action = action || {};
  if (action.trim) {
    action = {
      type: action
    };
    params && (action.params = params);
  }
  return (0, _callFunc["default"])(action, [prevState]);
};

/**
 * @typedef {Object} Store
 * @property {function} reset
 * @property {function} getState
 * @property {function} addListener
 * @property {function} removeListener
 */

/**
 * @template T
 * @param {function} reduce
 * @param {state<T>|function} initState
 * @returns {[Store, dispatch]}
 */
exports.refineAction = refineAction;
var createReducer = function createReducer(reduce, initState) {
  if (initState === void 0) {
    initState = function initState() {
      return {};
    };
  }
  var state = {
    current: (0, _callFunc["default"])(initState)
  };
  var mitt = getMitt();
  /**
   * @param {string|object|function} action
   * @param {object} actionParams
   * @returns {state<T>} endingState
   */
  var dispatch = function dispatch(action, actionParams) {
    if (actionParams === void 0) {
      actionParams = _reshowConstant.T_UNDEFINED;
    }
    var startingState = state.current;
    action = refineAction(action, actionParams, startingState);
    var endingState = reduce(startingState, action);
    if (endingState === _reshowConstant.T_UNDEFINED) {
      console.trace();
      throw "reduce() return " + _reshowConstant.UNDEFINED + ".";
    }
    if (startingState !== endingState) {
      state.current = endingState;
      mitt.emit(endingState, action, startingState);
    }
    return endingState;
  };
  var store = {
    reset: function reset() {
      return mitt.reset() && (0, _callFunc["default"])(initState);
    },
    getState: function getState() {
      return state.current;
    },
    addListener: mitt.add,
    removeListener: mitt.remove
  };
  return [store, dispatch];
};
var _default = createReducer;
exports["default"] = _default;