import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
// @ts-check
import { Map, Set, fromJS, is as equal } from "immutable";
import { createReducer } from "reshow-flux-base";
import { OBJ_SIZE, KEYS, STRING } from "reshow-constant";
import callfunc from "call-func";
import toJS from "./toJS.mjs";
/**
 * @typedef {object} StateType
 * @property {function} get
 * @property {function} set
 */

/**
 * @typedef {StateType|Object} MaybeMapType
 */

/**
 * @callback forEachCb
 * @param {any} Value
 * @param {number|string} Key
 * @returns {void}
 */

/**
 * @param {StateType} state
 * @param {string} k
 * @returns {object}
 */

var _getMap = function getMap(state, k) {
  var _toJS;

  return (_toJS = toJS(state.get(k))) !== null && _toJS !== void 0 ? _toJS : {};
};

var isMap = Map.isMap;
/**
 * @param {MaybeMapType} maybeMap
 * @param {forEachCb} cb
 */

var forEachMap = function forEachMap(maybeMap, cb) {
  if (!MAP_SIZE(maybeMap)) {
    return;
  }

  if (isMap(maybeMap)) {
    maybeMap.forEach(cb);
  } else {
    if (STRING === typeof maybeMap) {
      /**
       * Use with mergeMap
       * will set string with key type such as
       * { type: "this-string" }
       */
      cb(maybeMap, "type");
    } else {
      KEYS(maybeMap).forEach(function (k) {
        return cb(maybeMap[k], k);
      });
    }
  }
};
/**
 * @param {MaybeMapType} maybeMap
 * @returns {number}
 */


var MAP_SIZE = function MAP_SIZE(maybeMap) {
  return isMap(maybeMap) ? maybeMap.size : OBJ_SIZE(maybeMap);
};
/**
 * Why not just use immutable mergeMap?
 * Because after merge can not use === to compare
 * https://github.com/react-atomic/reshow/issues/123
 *
 * @param {StateType} state
 * @param {MaybeMapType} maybeMap
 * @returns {StateType}
 */


var mergeMap = function mergeMap(state, maybeMap) {
  try {
    forEachMap(maybeMap, function (v, k) {
      state = state.set(k, v);
    });
  } catch (e) {}

  return state;
};
/**
 * @callback ReducerType
 * @param {StateType} state
 * @param {MaybeMapType} action
 * @returns {StateType}
 */

/**
 * @type ReducerType
 */


var defaultReducer = function defaultReducer(state, action) {
  return mergeMap(state, action);
};
/**
 * @typedef {Object} ImmutableStore
 * @property {function} getMap
 */

/**
 * @param {ReducerType} reduce
 * @param {MaybeMapType|function} initState
 * @returns {[store & ImmutableStore, dispatch]}
 */


var ImmutableStore = function ImmutableStore(reduce, initState) {
  reduce = reduce || defaultReducer;
  initState = mergeMap(Map(), callfunc(initState));
  var [store, dispatch] = createReducer(reduce, initState);
  return [_objectSpread(_objectSpread({}, store), {}, {
    /**
     * @param {string} k
     */
    getMap: function getMap(k) {
      return _getMap(store.getState(), k);
    }
  }), dispatch];
};

export default ImmutableStore;
export { defaultReducer, equal, forEachMap, fromJS, mergeMap, Map, Set };