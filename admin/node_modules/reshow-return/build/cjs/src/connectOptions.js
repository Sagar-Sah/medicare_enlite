"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.stateKeyLocator = exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("reshow-runtime/helpers/toConsumableArray"));

var _getObjectValue = _interopRequireDefault(require("get-object-value"));

var _callFunc = _interopRequireDefault(require("call-func"));

var _reshowFlux = require("reshow-flux");

var _reshowConstant = require("reshow-constant");

var getImmutable = function getImmutable(immutable) {
  return function (data) {
    return !immutable ? (0, _reshowFlux.toJS)(data) : data;
  };
};

var reset = function reset(props, more) {
  var cleanKeys = ["immutable", "initStates", "pathStates", "renewProps", "store", "storeLocator"].concat((0, _toConsumableArray2["default"])(more || []));
  var i = cleanKeys.length;
  /**
   * Why use undefined?
   * https://github.com/react-atomic/reshow/issues/117
   *
   * Why could use undefined?
   * because reshow-build have remove empty to clean undefined.
   * if u use react directly, react will complain error.
   *
   */

  while (i--) {
    var key = cleanKeys[i];
    props[key] && (props[key] = _reshowConstant.T_UNDEFINED);
  }

  return props;
};

var stateValueGetter = function stateValueGetter(state) {
  return function (k) {
    return state.get ? state.get(k) : (0, _getObjectValue["default"])(state, [k]);
  };
};

var stateKeyLocator = function stateKeyLocator(initStates) {
  var keys;
  var getNewKey;

  if ((0, _reshowConstant.IS_ARRAY)(initStates)) {
    keys = initStates;

    getNewKey = function getNewKey(key) {
      return key;
    };
  } else {
    keys = initStates ? (0, _reshowConstant.KEYS)(initStates) : [];

    getNewKey = function getNewKey(key) {
      return null != initStates[key] ? initStates[key] : key;
    };
  }

  return [keys, getNewKey];
};

exports.stateKeyLocator = stateKeyLocator;

var calculateState = function calculateState(prevState, options) {
  /**
   * Why not support multi stores?
   * Because multi stores need handle complex data merge.
   * If that case need create custom calculateState functoin.
   */
  var initStates = options.initStates,
      pathStates = options.pathStates,
      optImmutable = options.immutable,
      store = options.store;
  var getStateValue = stateValueGetter(store.getState());
  var immutable = optImmutable !== null && optImmutable !== void 0 ? optImmutable : getStateValue("immutable");
  var results = {};
  var toImmutable = getImmutable(immutable);

  var _stateKeyLocator = stateKeyLocator(initStates),
      stateKeys = _stateKeyLocator[0],
      newKey = _stateKeyLocator[1];

  stateKeys.forEach(function (key) {
    var data = getStateValue(key);
    results[newKey(key)] = toImmutable(data);
  });
  (0, _reshowConstant.KEYS)(pathStates || {}).forEach(function (key) {
    return results[key] = (0, _getObjectValue["default"])(results, pathStates[key]);
  });
  var resultKeys = (0, _reshowConstant.KEYS)(results);
  var bSame = true;
  var i = resultKeys.length;

  while (i--) {
    var key = resultKeys[i];

    if (results[key] !== prevState[key]) {
      bSame = false;
      break;
    }
  }

  return bSame ? prevState : results;
};

var connectOptions = {
  calculateState: calculateState,
  reset: reset
};
var _default = connectOptions;
exports["default"] = _default;