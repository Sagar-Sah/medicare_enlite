import _toConsumableArray from "reshow-runtime/es/helpers/toConsumableArray";
import get from "get-object-value";
import callfunc from "call-func";
import { toJS } from "reshow-flux";
import { IS_ARRAY, KEYS, T_UNDEFINED } from "reshow-constant";

var getImmutable = function getImmutable(immutable) {
  return function (data) {
    return !immutable ? toJS(data) : data;
  };
};

var reset = function reset(props, more) {
  var cleanKeys = ["immutable", "initStates", "pathStates", "renewProps", "store", "storeLocator"].concat(_toConsumableArray(more || []));
  var i = cleanKeys.length;
  /**
   * Why use undefined?
   * https://github.com/react-atomic/reshow/issues/117
   *
   * Why could use undefined?
   * because reshow-build have remove empty to clean undefined.
   * if u use react directly, react will complain error.
   *
   */

  while (i--) {
    var key = cleanKeys[i];
    props[key] && (props[key] = T_UNDEFINED);
  }

  return props;
};

var stateValueGetter = function stateValueGetter(state) {
  return function (k) {
    return state.get ? state.get(k) : get(state, [k]);
  };
};

var stateKeyLocator = function stateKeyLocator(initStates) {
  var keys;
  var getNewKey;

  if (IS_ARRAY(initStates)) {
    keys = initStates;

    getNewKey = function getNewKey(key) {
      return key;
    };
  } else {
    keys = initStates ? KEYS(initStates) : [];

    getNewKey = function getNewKey(key) {
      return null != initStates[key] ? initStates[key] : key;
    };
  }

  return [keys, getNewKey];
};

var calculateState = function calculateState(prevState, options) {
  /**
   * Why not support multi stores?
   * Because multi stores need handle complex data merge.
   * If that case need create custom calculateState functoin.
   */
  var {
    initStates,
    pathStates,
    immutable: optImmutable,
    store
  } = options;
  var getStateValue = stateValueGetter(store.getState());
  var immutable = optImmutable !== null && optImmutable !== void 0 ? optImmutable : getStateValue("immutable");
  var results = {};
  var toImmutable = getImmutable(immutable);
  var [stateKeys, newKey] = stateKeyLocator(initStates);
  stateKeys.forEach(function (key) {
    var data = getStateValue(key);
    results[newKey(key)] = toImmutable(data);
  });
  KEYS(pathStates || {}).forEach(function (key) {
    return results[key] = get(results, pathStates[key]);
  });
  var resultKeys = KEYS(results);
  var bSame = true;
  var i = resultKeys.length;

  while (i--) {
    var key = resultKeys[i];

    if (results[key] !== prevState[key]) {
      bSame = false;
      break;
    }
  }

  return bSame ? prevState : results;
};

var connectOptions = {
  calculateState,
  reset
};
export default connectOptions;
export { stateKeyLocator };