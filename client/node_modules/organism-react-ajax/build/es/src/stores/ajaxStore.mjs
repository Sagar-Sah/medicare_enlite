import _classCallCheck from "reshow-runtime/es/helpers/classCallCheck";
import _createClass from "reshow-runtime/es/helpers/createClass";
import _defineProperty from "reshow-runtime/es/helpers/defineProperty";
import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
// @ts-check

import { mergeMap, ImmutableStore, Map } from "reshow-flux";
import get, { getDefault } from "get-object-value";
import set from "set-object-value";
import smoothScrollTo from "smooth-scroll-to";
import getRandomId, { getTimestamp, getSN } from "get-random-id";
import callfunc from "call-func";
import { KEYS, REAL_TIME_URL, REAL_TIME_DATA_KEY } from "reshow-constant";
var empty = function empty() {};
var Callbacks = [];
var wsAuth = Map();
var gWorker;
var fakeWorker = false;
var isWorkerReady;
var hasUrl = function hasUrl(s) {
  return s && "#" !== s && "?" !== s;
};
var initAjaxWorkerEvent = function initAjaxWorkerEvent(worker) {
  worker.addEventListener("message", function (e) {
    var sourceType = get(e, ["data", "type"]);
    switch (sourceType) {
      case "ready":
        // fakeWorker will not run this
        gWorker = worker;
        isWorkerReady = true;
        break;
      default:
        var nextState = _objectSpread(_objectSpread({}, e.data), {}, {
          sourceType,
          type: "callback"
        });
        ajaxDispatch(nextState);
        break;
    }
  });
};
var initFakeWorker = function initFakeWorker(cb) {
  import("../worker.mjs").then(function (workerObject) {
    fakeWorker = getDefault(workerObject);
    initAjaxWorkerEvent(fakeWorker);
    if (!gWorker) {
      gWorker = fakeWorker;
    }
    isWorkerReady = true;
    cb();
  });
};
var handleUseNewUrl = function handleUseNewUrl(state, action, url) {
  var prevUrl = state.get("currentLocation");
  if (prevUrl !== url) {
    var onUrlChange = state.get("onUrlChange");
    state = mergeMap(state.delete("themePath").set("currentLocation", url), callfunc(onUrlChange, [url, {
      state,
      action
    }]));
  }
  return state;
};
var getCallback = function getCallback(state, action, json, response) {
  var params = get(action, ["params"], {});
  var callback;
  if (get(json, ["data", "errors"]) || !get(response, ["ok"])) {
    if (params.errorCallback) {
      callback = Callbacks[params.errorCallback];
      delete Callbacks[params.errorCallback];
    }
  }
  var debugs = json.debugs;
  if (debugs) {
    var bFail = false;
    import("../lib/dlog.mjs").then(function (dlog) {
      var DLOG = getDefault(dlog);
      var oLog = new DLOG({
        level: "trace"
      });
      debugs.forEach(function (v) {
        var dump = get(oLog, [v[0]], function () {
          return oLog.info;
        });
        dump.call(oLog, v[1]);
      });
    });
    debugs.forEach(function (v) {
      if ("error" === v[1]) {
        bFail = true;
      }
    });
    if (bFail) {
      return empty;
    }
  }
  if (!callback) {
    if (params.callback) {
      callback = Callbacks[params.callback];
      delete Callbacks[params.callback];
    } else {
      callback = state.get("callback");
    }
  }
  return callback;
};
var getRawUrl = function getRawUrl(_temp) {
  var {
    url = null,
    path = null,
    baseUrl = null
  } = _temp === void 0 ? {} : _temp;
  if (!hasUrl(url)) {
    if (path) {
      baseUrl = baseUrl || store.getState().get("baseUrl") || "";
      url = baseUrl + path;
    } else {
      url = "#";
    }
  }
  return url;
};
var cookAjaxUrl = function cookAjaxUrl(params, ajaxUrl, globalHeaders) {
  if (globalHeaders && !get(params, ["ignoreGlobalHeaders"])) {
    if (globalHeaders.toJS) {
      params.globalHeaders = globalHeaders.toJS();
    } else {
      console.error("Global headers should be a map.", globalHeaders);
    }
  }
  var urls = ajaxUrl.split("#");
  var query = get(params, ["query"], {});
  if (urls[1]) {
    query["--hashState"] = urls[1];
  }

  // <!-- Clean key for fixed superagent error
  if (query) {
    KEYS(query).forEach(function (key) {
      if ("undefined" === typeof query[key]) {
        delete query[key];
      }
    });
    params.query = query;
  }
  // -->

  return urls[0];
};
var handleAjax = /*#__PURE__*/function () {
  function handleAjax() {
    _classCallCheck(this, handleAjax);
    _defineProperty(this, "queue", []);
  }
  _createClass(handleAjax, [{
    key: "worker",
    value: function worker(data) {
      var _this = this;
      if (isWorkerReady && fakeWorker) {
        var disableWebWorker = get(data, ["action", "params", "disableWebWorker"]);
        var run = disableWebWorker ? fakeWorker : gWorker;
        run.postMessage(data);
      } else {
        if (false === fakeWorker) {
          initFakeWorker(function () {
            _this.queue.forEach(function (d) {
              return _this.worker(d);
            });
          });
          fakeWorker = null;
        }
        this.queue.push(data);
      }
    }
  }, {
    key: "start",
    value: function start(state) {
      return state.set("isRunning", 1);
    }
  }, {
    key: "done",
    value: function done() {
      // update progress should run very end.
      setTimeout(function () {
        return ajaxDispatch({
          isRunning: 0
        });
      }, 500);
    }
  }, {
    key: "storeCallback",
    value: function storeCallback(action) {
      var cb = get(action, ["params", "callback"]);
      if (cb) {
        var cbKey = getSN("cb");
        Callbacks[cbKey] = cb;
        action.params.callback = cbKey;
      }
      var err = get(action, ["params", "errorCallback"]);
      if (err) {
        var errCbKey = getSN("err");
        Callbacks[errCbKey] = err;
        action.params.errorCallback = errCbKey;
      }
      var wcb = get(action, ["params", "workerCallback"]);
      if (wcb) {
        action.params.workerCallback = wcb + "";
      }
      return action;
    }
  }, {
    key: "setWsAuth",
    value: function setWsAuth(key, data) {
      wsAuth = wsAuth.set(key, data);
    }
  }, {
    key: "getWsAuth",
    value: function getWsAuth(key) {
      if (!key) {
        return wsAuth.toJS();
      } else {
        return wsAuth.get(key).toJS();
      }
    }
  }, {
    key: "initWs",
    value: function initWs(state, action) {
      var params = get(action, ["params"], {});
      var {
        url
      } = params;
      if (url) {
        this.worker({
          params,
          ws: url,
          type: "initWs"
        });
      }
      return state;
    }
  }, {
    key: "closeWs",
    value: function closeWs(state, action) {
      var url = get(action, ["params", "url"]);
      if (url) {
        this.worker({
          ws: url,
          type: "closeWs"
        });
      }
      return state;
    }
  }, {
    key: "ajaxGet",
    value: function ajaxGet(state, action) {
      var params = action.params;
      var rawUrl = getRawUrl(params);
      if (params.updateUrl && store.urlDispatch && rawUrl !== document.URL) {
        store.urlDispatch({
          type: "url",
          url: rawUrl
        });
      }
      if (params.disableAjax) {
        return this.applyCallback(state, {
          params: {
            json: handleUseNewUrl(state, action, rawUrl),
            disableAjax: params.disableAjax,
            scrollBack: params.scrollBack
          }
        });
      }
      if (!params.disableProgress) {
        state = this.start(state);
      }
      var ajaxUrl = cookAjaxUrl(params, rawUrl, state.get("globalHeaders"));
      if (!params.query) {
        params.query = {};
      }
      if (!params.disableCacheBusting) {
        params.query["--r"] = params.randomCacheBusting ? getRandomId() : Math.floor(getTimestamp() / 60000);
      } else {
        params.query["--r"] = state.get("staticVersion");
      }
      this.worker({
        type: "ajaxGet",
        url: ajaxUrl,
        action: this.storeCallback(action)
      });
      return state;
    }
  }, {
    key: "ajaxPost",
    value: function ajaxPost(state, action) {
      var params = action.params;
      if (!params.disableProgress) {
        state = this.start(state);
      }
      var rawUrl = getRawUrl(params);
      var ajaxUrl = cookAjaxUrl(params, rawUrl, state.get("globalHeaders"));
      this.worker({
        type: "ajaxPost",
        url: ajaxUrl,
        action: this.storeCallback(action)
      });
      return state;
    }
  }, {
    key: "applyCallback",
    value: function applyCallback(state, action) {
      var sourceType = get(action, ["sourceType"]);
      var params = get(action, ["params"], {});
      if (!params.disableProgress) {
        this.done();
      }
      var response = get(params, ["response"]);
      var text = get(params, ["text"]);
      var json = get(params, ["json"], {});
      var callback = getCallback(state, action, json, response);
      var url = get(params, ["url"]);
      var isRedirect = null;
      switch (json.type) {
        case "ws-auth":
          this.setWsAuth(url, json);
          break;
        default:
          if ("ws" === sourceType) {
            json[REAL_TIME_URL] = url;
            json[REAL_TIME_DATA_KEY] = json;
          }
          isRedirect = callfunc(callback, [json, text, response]);
          break;
      }
      if (false !== isRedirect) {
        var loc = json.clientRedirectTo;
        if (loc) {
          switch (json.clientRedirectType) {
            case "href":
              location.href = loc;
              break;
            case "replace":
            default:
              location.replace(loc);
              break;
          }
        }
      }
      if (params.disableAjax && false !== params.scrollBack || params.updateUrl && false !== params.scrollBack || params.scrollBack) {
        smoothScrollTo(0);
      }
      return state.set("currentLocation", json.currentLocation);
    }
  }, {
    key: "handleUrlChange",
    value: function handleUrlChange(state, action) {
      var url = get(action, ["params", "url"], document.URL);
      /**
       * "!! Important !!" don't modify states of toggleBfChange and bfApplyUrl in other way,
       * such as ajaxGet.
       * Because this state should only trigger with bfchange.
       */
      return this.applyCallback(state.set("toggleBfChange", !state.get("toggleBfChange")).set("bfApplyUrl", url), {
        params: {
          json: handleUseNewUrl(state, action, url)
        }
      });
    }
  }]);
  return handleAjax;
}();
var oAjax = new handleAjax();

/**
 * @typedef {object} StateType
 * @property {function} get
 * @property {function} set
 */

/**
 * @typedef {StateType|Object} MaybeMapType
 */

/**
 * @typedef {Object} AjaxStore
 * @property {function} urlDispatch
 */

/**
 * @callback ReducerType
 * @param {StateType} state
 * @param {MaybeMapType} action
 * @returns {StateType}
 */

/**
 * @param {ReducerType} reduce
 * @param {MaybeMapType|function} initState
 * @returns {[store & AjaxStore, dispatch]}
 */
var AjaxStore = function AjaxStore(reduce, initState) {
  var [store, dispatch] = ImmutableStore(reduce, initState);
  return [_objectSpread(_objectSpread({}, store), {}, {
    urlDispatch: function urlDispatch() {}
  }), dispatch];
};
var [store, ajaxDispatch] = AjaxStore(function (state, action) {
  var type = action.type;
  switch (type) {
    case "ws/init":
      return oAjax.initWs(state, action);
    case "ws/close":
      return oAjax.closeWs(state, action);
    case "ajaxGet":
      return oAjax.ajaxGet(state, action);
    case "ajaxDelete":
    case "ajaxHead":
    case "ajaxPatch":
    case "ajaxPut":
      set(action, ["params", "method"], type.substr(4).toLowerCase());
    case "ajaxPost":
      return oAjax.ajaxPost(state, action);
    case "urlChange":
      return oAjax.handleUrlChange(state, action);
    case "callback":
      return oAjax.applyCallback(state, action);
    default:
      if (KEYS(action).length) {
        return mergeMap(state, action);
      } else {
        return state;
      }
  }
}, function () {
  var onUrlChange = function onUrlChange(url) {
    ajaxDispatch({
      type: "ajaxGet",
      params: {
        url,
        scrollBack: true
      }
    });
  };
  return Map({
    onUrlChange
  });
});
export default store;
export { initAjaxWorkerEvent, ajaxDispatch, getRawUrl, hasUrl };