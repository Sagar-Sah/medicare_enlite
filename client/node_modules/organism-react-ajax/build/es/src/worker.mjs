import _classCallCheck from "reshow-runtime/es/helpers/classCallCheck";
import _createClass from "reshow-runtime/es/helpers/createClass";
import _defineProperty from "reshow-runtime/es/helpers/defineProperty";
import _objectWithoutProperties from "reshow-runtime/es/helpers/objectWithoutProperties";
import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
var _excluded = ["error", "req", "text", "xhr"],
  _excluded2 = ["id", "query", "isSendJson", "cookHeaders", "responseType"],
  _excluded3 = ["error", "req", "text", "xhr"];
var _this = this;
import get, { getDefault } from "get-object-value";
import nonWorker from "non-worker";
import req from "superagent";
import ini from "parse-ini-string";
import { nest } from "object-nested";
import { KEYS } from "reshow-constant";
var arrWs = {};
var arrReq = {};
var getJson = function getJson(text) {
  var json;
  try {
    json = JSON.parse(text);
  } catch (e) {}
  return json || {};
};
var oNonWorker = new nonWorker(function (e) {
  var data = get(e, ["data"]);
  switch (data.type) {
    case "initWs":
      initWs(data.ws)(data.params);
      break;
    case "closeWs":
      closeWs(data.ws);
      break;
    case "ajaxGet":
      ajaxGet(data);
      break;
    case "ajaxPost":
      ajaxPost(data);
      break;
  }
});
var post = function post(payload) {
  var strWcb = get(payload, ["params", "workerCallback"]);
  var parseIni = get(payload, ["params", "ini"]);
  var text = get(payload, ["params", "text"]);
  payload.params.json = parseIni ? nest(ini(text), "_") : getJson(text);
  if (strWcb) {
    var wcb = eval("(" + strWcb + ")");
    payload = wcb(payload);
  }
  oNonWorker.post.call(_this, payload);
};
export default oNonWorker;
var cookParams = function cookParams(action, callReq) {
  var params = get(action, ["params"], {});
  var id = params.id;
  if (id) {
    if (arrReq[id]) {
      arrReq[id].abort();
    }
    arrReq[id] = callReq;
  }
  var cookHeaders = _objectSpread(_objectSpread(_objectSpread({}, get(params, ["globalHeaders"], {})), get(params, ["headers"], {})), {}, {
    Accept: get(params, ["accept"], "application/json")
  });
  params.cookHeaders = cookHeaders;
  var superagent = params.superagent || {};
  var syncKeys = ["responseType"];
  syncKeys.forEach(function (key) {
    if (params[key]) {
      superagent[key] = params[key];
    }
  });
  KEYS(superagent).forEach(function (key) {
    callReq = callReq[key].apply(callReq, superagent[key]);
  });
  return params;
};
var ajaxGet = function ajaxGet(_ref) {
  var {
    url,
    action
  } = _ref;
  var callReq = req.get(url);
  var {
    query,
    cookHeaders,
    id
  } = cookParams(action, callReq);
  callReq.query(query).set(cookHeaders).end(function (err, res) {
    if (res) {
      if (arrReq[id]) {
        delete arrWs[id];
      }
      var {
          error,
          req: _req,
          text,
          xhr
        } = res,
        response = _objectWithoutProperties(res, _excluded);
      action.params = _objectSpread(_objectSpread({}, action.params), {}, {
        text,
        response
      });
      post(action);
    }
  });
};
var ajaxPost = function ajaxPost(_ref2) {
  var {
    url,
    action
  } = _ref2;
  var callReq;
  switch (get(action, ["params", "method"])) {
    case "delete":
      callReq = req.del(url);
      break;
    case "head":
      callReq = req.head(url);
      break;
    case "patch":
      callReq = req.patch(url);
      break;
    case "put":
      callReq = req.put(url);
      break;
    default:
      callReq = req.post(url);
      break;
  }
  var _cookParams = cookParams(action, callReq),
    {
      id,
      query,
      isSendJson,
      cookHeaders,
      responseType
    } = _cookParams,
    params = _objectWithoutProperties(_cookParams, _excluded2);
  var isSend = false;
  if (isSendJson) {
    isSend = true;
  } else {
    if (null == isSendJson && query) {
      KEYS(query).every(function (key) {
        if ("object" !== typeof query[key]) {
          return true;
        }
        isSend = true;
        return false;
      });
    }
  }
  if (!isSend) {
    callReq = callReq.type("form");
  }
  callReq.send(query).set(cookHeaders).end(function (err, res) {
    if (res) {
      if (arrReq[id]) {
        delete arrWs[id];
      }
      var {
          error,
          req: _req2,
          text,
          xhr
        } = res,
        response = _objectWithoutProperties(res, _excluded3);
      action.params = _objectSpread(_objectSpread({}, action.params), {}, {
        text,
        response
      });
      post(action);
    }
  });
};
var closeWs = function closeWs(url) {
  if (arrWs[url]) {
    arrWs[url].close();
    delete arrWs[url];
  }
  return !arrWs[url];
};
var WebSocketHelper = /*#__PURE__*/function () {
  function WebSocketHelper(url, params) {
    _classCallCheck(this, WebSocketHelper);
    _defineProperty(this, "isWsConnect", false);
    this.ws = null;
    this.pingTimeout = null;
    this.url = url;
    this.params = params;
    this.open();
  }
  _createClass(WebSocketHelper, [{
    key: "open",
    value: function open() {
      var _this2 = this;
      if (this.isWsConnect) {
        return;
      }
      var url = this.url;
      var params = this.params;

      /**
       * Can't try catch
       * WebSocket connection to 'xxx' failed
       * use onerror instead.
       */
      var ws = new WebSocket(url);
      this.ws = ws;
      ws.onopen = function (e) {
        _this2.isWsConnect = true;
        _this2.ping();
        var {
          messages
        } = params;
        if (get(messages, ["length"])) {
          messages.forEach(function (m) {
            return ws.send(JSON.stringify(m));
          });
        }
      };
      ws.onerror = function (e) {
        _this2.isWsConnect = false;
        _this2.ping();
      };
      ws.onmessage = function (e) {
        switch (e.data) {
          case "pong":
            break;
          default:
            post({
              type: "ws",
              params: {
                text: e.data,
                url
              }
            });
            break;
        }
      };
      ws.onclose = function (e) {
        _this2.isWsConnect = false;
        console.warn("WS close.", url);
      };
    }
  }, {
    key: "close",
    value: function close() {
      this.ws.close();
      this.clearPing();
    }
  }, {
    key: "clearPing",
    value: function clearPing() {
      if (this.pingTimeout) {
        clearTimeout(this.pingTimeout);
        this.pingTimeout = null;
      }
    }
  }, {
    key: "ping",
    value: function ping() {
      var _this3 = this;
      this.clearPing();
      this.pingTimeout = setTimeout(function () {
        if (!_this3.isWsConnect) {
          console.warn("Try restore ws connection.", _this3.url);
          _this3.open();
        } else {
          _this3.ws.send(JSON.stringify({
            type: "ping"
          }));
        }
        _this3.ping();
      }, 15000);
    }
  }]);
  return WebSocketHelper;
}();
var initWs = function initWs(url) {
  return function (params) {
    var create = function create() {
      arrWs[url] = new WebSocketHelper(url, params);
    };
    if (!arrWs[url]) {
      create(url);
    }
  };
};