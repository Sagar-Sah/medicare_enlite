"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("reshow-runtime/helpers/objectWithoutPropertiesLoose"));

var _react = require("react");

var _reactAtomicMolecule = require("react-atomic-molecule");

var _callFunc = _interopRequireDefault(require("call-func"));

var _reshowHooks = require("reshow-hooks");

var _const = require("../../const.js");

var _excluded = ["component", "statusKey", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "in", "beforeEnter", "afterEnter", "onEnter", "onEntering", "onEntered", "beforeExit", "afterExit", "onExit", "onExiting", "onExited", "children", "timeout", "addEndListener"];

/**
 * @typedef {object} TimeoutType
 * @property {number} exit
 * @property {number} enter
 * @property {number} appear
 */

/**
 * @param {Object} timeout
 * @returns {TimeoutType}
 */
var getTimeouts = function getTimeouts(timeout) {
  var exit, enter, appear;
  exit = enter = appear = timeout;

  if (timeout != null && typeof timeout !== "number") {
    var _timeout$appear;

    exit = timeout.exit;
    enter = timeout.enter;
    appear = (_timeout$appear = timeout.appear) !== null && _timeout$appear !== void 0 ? _timeout$appear : enter;
  }

  return {
    exit: exit,
    enter: enter,
    appear: appear
  };
};
/**
 * @param {function} callback
 */


var setNextCallback = function setNextCallback(callback) {
  var active = true;
  /**
   * @param {string} event
   */

  var nextCallback = function nextCallback(event) {
    if (active) {
      (0, _callFunc["default"])(callback, [event]);
    }

    nextCallback.reset();
  };

  nextCallback.reset = function () {
    active = false;
  };

  return nextCallback;
};
/**
 * @param {Object} lastData
 */


var cancelNextCallback = function cancelNextCallback(lastData) {
  if (lastData.current.nextCallback !== null) {
    lastData.current.nextCallback.reset();
    lastData.current.nextCallback = null;
  }
};

var perform = function perform(_ref) {
  var isAppear = _ref.isAppear,
      step1 = _ref.step1,
      step1Cb = _ref.step1Cb,
      step2 = _ref.step2,
      step2Cb = _ref.step2Cb,
      step3 = _ref.step3,
      step3Cb = _ref.step3Cb,
      setUp = _ref.setUp,
      safeSetState = _ref.safeSetState,
      onTransitionEnd = _ref.onTransitionEnd,
      tearDown = _ref.tearDown,
      goToLast = _ref.goToLast,
      node = _ref.node,
      timeout = _ref.timeout;

  var last = function last() {
    onTransitionEnd(function () {
      safeSetState(step3, function () {
        (0, _callFunc["default"])(step3Cb, [node, isAppear]);
        setTimeout(function () {
          return (0, _callFunc["default"])(tearDown, [node, isAppear]);
        });
      });
    }, timeout, node);
  };

  (0, _callFunc["default"])(setUp, [node, isAppear]);

  if (goToLast) {
    last();
  } else {
    safeSetState(step1, function () {
      (0, _callFunc["default"])(step1Cb, [node, isAppear]);
      safeSetState(step2, function () {
        (0, _callFunc["default"])(step2Cb, [node, isAppear]);
        last();
      });
    });
  }
};

var useTransition = function useTransition(_ref2) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? _reactAtomicMolecule.SemanticUI : _ref2$component,
      _ref2$statusKey = _ref2.statusKey,
      statusKey = _ref2$statusKey === void 0 ? _const.dataStatusKey : _ref2$statusKey,
      _ref2$mountOnEnter = _ref2.mountOnEnter,
      mountOnEnter = _ref2$mountOnEnter === void 0 ? false : _ref2$mountOnEnter,
      _ref2$unmountOnExit = _ref2.unmountOnExit,
      unmountOnExit = _ref2$unmountOnExit === void 0 ? false : _ref2$unmountOnExit,
      _ref2$appear = _ref2.appear,
      appear = _ref2$appear === void 0 ? false : _ref2$appear,
      _ref2$enter = _ref2.enter,
      enter = _ref2$enter === void 0 ? true : _ref2$enter,
      _ref2$exit = _ref2.exit,
      exit = _ref2$exit === void 0 ? true : _ref2$exit,
      _ref2$in = _ref2["in"],
      propsIn = _ref2$in === void 0 ? false : _ref2$in,
      beforeEnter = _ref2.beforeEnter,
      afterEnter = _ref2.afterEnter,
      onEnter = _ref2.onEnter,
      onEntering = _ref2.onEntering,
      onEntered = _ref2.onEntered,
      beforeExit = _ref2.beforeExit,
      afterExit = _ref2.afterExit,
      onExit = _ref2.onExit,
      onExiting = _ref2.onExiting,
      onExited = _ref2.onExited,
      children = _ref2.children,
      timeout = _ref2.timeout,
      addEndListener = _ref2.addEndListener,
      otherProps = (0, _objectWithoutPropertiesLoose2["default"])(_ref2, _excluded);

  var _useState = (0, _react.useState)(function () {
    var initialStatus;

    if (propsIn) {
      if (appear) {
        initialStatus = _const.ENTERING;
      } else {
        initialStatus = _const.ENTERED;
      }
    } else {
      if (unmountOnExit || mountOnEnter) {
        initialStatus = _const.UNMOUNTED;
      } else {
        initialStatus = _const.EXITED;
      }
    }

    return initialStatus;
  }),
      status = _useState[0],
      setStatus = _useState[1];

  var lastNode = (0, _react.useRef)();
  var lastData = (0, _react.useRef)({
    "in": null,
    callbackWith: null,
    nextCallback: null,
    init: false
  });

  var _useTimer = (0, _reshowHooks.useTimer)(),
      TransitionEndTimer = _useTimer[0],
      StopTransitionEndTimer = _useTimer[1];

  (0, _react.useEffect)(function () {
    /**
     * @param {string} nextStatus
     * @param {function} callback
     */
    var safeSetState = function safeSetState(nextStatus, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      lastData.current.callbackWith = nextStatus;
      lastData.current.nextCallback = callback ? setNextCallback(callback) : null;
      setStatus(nextStatus);
    };
    /**
     * @param {function} handler
     * @param {number} timeout
     * @param {HTMLElement} node
     */


    var onTransitionEnd = function onTransitionEnd(handler, timeout, node) {
      var callback = setNextCallback(function () {
        (0, _callFunc["default"])(handler);
        (0, _callFunc["default"])(addEndListener, [{
          node: node,
          state: lastData.current,
          status: status
        }]);
      });
      lastData.current.nextCallback = callback;
      TransitionEndTimer(function () {
        return (0, _callFunc["default"])(lastData.current.nextCallback, ["onTransitionEnd"]);
      }, timeout || 0);
    };
    /**
     * @param {boolean} mounting
     * @param {string} nextStatus
     */


    var updateStatus = function updateStatus(mounting, nextStatus) {
      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        cancelNextCallback(lastData);
        var timeouts = getTimeouts(timeout);

        if (nextStatus === _const.ENTERING) {
          perform({
            setUp: beforeEnter,
            tearDown: afterEnter,
            step1: _const.ENTERSTART,
            step1Cb: onEnter,
            step2: _const.ENTERING,
            step2Cb: onEntering,
            step3: _const.ENTERED,
            step3Cb: onEntered,
            goToLast: mounting && !appear || !mounting && !enter,
            node: lastNode.current,
            safeSetState: safeSetState,
            onTransitionEnd: onTransitionEnd,
            isAppear: mounting,
            timeout: mounting ? timeouts.appear : timeouts.enter
          });
        } else {
          perform({
            setUp: beforeExit,
            tearDown: afterExit,
            step1: _const.EXITSTART,
            step1Cb: onExit,
            step2: _const.EXITING,
            step2Cb: onExiting,
            step3: _const.EXITED,
            step3Cb: onExited,
            goToLast: !exit,
            node: lastNode.current,
            safeSetState: safeSetState,
            onTransitionEnd: onTransitionEnd,
            isAppear: mounting,
            timeout: timeouts.exit
          });
        }
      } else if (unmountOnExit && status === _const.EXITED) {
        setStatus(_const.UNMOUNTED);
      }
    };

    if (lastData.current.callbackWith === status) {
      (0, _callFunc["default"])(lastData.current.nextCallback, [status]);
    }

    if (lastData.current["in"] !== propsIn) {
      var nextStatus = null;
      var mounting = false;
      lastData.current["in"] = propsIn;

      if (propsIn) {
        if (status !== _const.ENTERING && status !== _const.ENTERED) {
          nextStatus = _const.ENTERING;
        } else if (!lastData.current.init) {
          lastData.current.init = true;

          if (appear) {
            nextStatus = _const.ENTERING;
            mounting = true;
          }
        }
      } else {
        if (status === _const.ENTERING || status === _const.ENTERED) {
          nextStatus = _const.EXITING;
        }
      }

      updateStatus(mounting, nextStatus);
    }

    return function () {
      // useEffect clean
      StopTransitionEndTimer();
    };
  }, [propsIn, status]); //end useEffect

  return {
    status: status,
    otherProps: otherProps,
    component: component,
    children: children,
    statusKey: statusKey,
    lastNode: lastNode
  };
};
/**
 * @typedef {Object} TransitionProps
 */

/**
 * @type React.FC<TransitionProps>
 */


var Transition = function Transition(props) {
  var _useTransition = useTransition(props),
      status = _useTransition.status,
      otherProps = _useTransition.otherProps,
      component = _useTransition.component,
      children = _useTransition.children,
      statusKey = _useTransition.statusKey,
      lastNode = _useTransition.lastNode;

  if (status !== _const.UNMOUNTED) {
    otherProps.children = children;
  }

  otherProps[statusKey] = status;
  otherProps.refCb = lastNode;
  return (0, _reactAtomicMolecule.build)(component)(otherProps);
};

var _default = Transition;
exports["default"] = _default;
module.exports = exports.default;