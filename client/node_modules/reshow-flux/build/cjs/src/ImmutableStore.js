"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.mergeMap = exports.forEachMap = exports.defaultReducer = exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("reshow-runtime/helpers/objectSpread2"));

var _immutable = require("immutable");

exports.Map = _immutable.Map;
exports.Set = _immutable.Set;
exports.fromJS = _immutable.fromJS;
exports.equal = _immutable.is;

var _reshowFluxBase = require("reshow-flux-base");

var _reshowConstant = require("reshow-constant");

var _callFunc = _interopRequireDefault(require("call-func"));

var _toJS2 = _interopRequireDefault(require("./toJS.js"));

// @ts-check

/**
 * @typedef {object} StateType
 * @property {function} get
 * @property {function} set
 */

/**
 * @typedef {StateType|Object} MaybeMapType
 */

/**
 * @callback forEachCb
 * @param {any} Value
 * @param {number|string} Key
 * @returns {void}
 */

/**
 * @param {StateType} state
 * @param {string} k
 * @returns {object}
 */
var _getMap = function getMap(state, k) {
  var _toJS;

  return (_toJS = (0, _toJS2["default"])(state.get(k))) !== null && _toJS !== void 0 ? _toJS : {};
};

var isMap = _immutable.Map.isMap;
/**
 * @param {MaybeMapType} maybeMap
 * @param {forEachCb} cb
 */

var forEachMap = function forEachMap(maybeMap, cb) {
  if (!MAP_SIZE(maybeMap)) {
    return;
  }

  if (isMap(maybeMap)) {
    maybeMap.forEach(cb);
  } else {
    if (_reshowConstant.STRING === typeof maybeMap) {
      /**
       * Use with mergeMap
       * will set string with key type such as
       * { type: "this-string" }
       */
      cb(maybeMap, "type");
    } else {
      (0, _reshowConstant.KEYS)(maybeMap).forEach(function (k) {
        return cb(maybeMap[k], k);
      });
    }
  }
};
/**
 * @param {MaybeMapType} maybeMap
 * @returns {number}
 */


exports.forEachMap = forEachMap;

var MAP_SIZE = function MAP_SIZE(maybeMap) {
  return isMap(maybeMap) ? maybeMap.size : (0, _reshowConstant.OBJ_SIZE)(maybeMap);
};
/**
 * Why not just use immutable mergeMap?
 * Because after merge can not use === to compare
 * https://github.com/react-atomic/reshow/issues/123
 *
 * @param {StateType} state
 * @param {MaybeMapType} maybeMap
 * @returns {StateType}
 */


var mergeMap = function mergeMap(state, maybeMap) {
  try {
    forEachMap(maybeMap, function (v, k) {
      state = state.set(k, v);
    });
  } catch (e) {}

  return state;
};
/**
 * @callback ReducerType
 * @param {StateType} state
 * @param {MaybeMapType} action
 * @returns {StateType}
 */

/**
 * @type ReducerType
 */


exports.mergeMap = mergeMap;

var defaultReducer = function defaultReducer(state, action) {
  return mergeMap(state, action);
};
/**
 * @typedef {Object} ImmutableStore
 * @property {function} getMap
 */

/**
 * @param {ReducerType} reduce
 * @param {MaybeMapType|function} initState
 * @returns {[store & ImmutableStore, dispatch]}
 */


exports.defaultReducer = defaultReducer;

var ImmutableStore = function ImmutableStore(reduce, initState) {
  reduce = reduce || defaultReducer;
  initState = mergeMap((0, _immutable.Map)(), (0, _callFunc["default"])(initState));

  var _createReducer = (0, _reshowFluxBase.createReducer)(reduce, initState),
      store = _createReducer[0],
      dispatch = _createReducer[1];

  return [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, store), {}, {
    /**
     * @param {string} k
     */
    getMap: function getMap(k) {
      return _getMap(store.getState(), k);
    }
  }), dispatch];
};

var _default = ImmutableStore;
exports["default"] = _default;