import _classCallCheck from "reshow-runtime/es/helpers/classCallCheck";
import _createClass from "reshow-runtime/es/helpers/createClass";
import _assertThisInitialized from "reshow-runtime/es/helpers/assertThisInitialized";
import _inherits from "reshow-runtime/es/helpers/inherits";
import _createSuper from "reshow-runtime/es/helpers/createSuper";
import _defineProperty from "reshow-runtime/es/helpers/defineProperty";
import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _asyncToGenerator from "reshow-runtime/es/helpers/asyncToGenerator";
import { useState, Component } from "react";
import { createReducer } from "reshow-flux-base";
import { expect } from "chai";
import { act, render, screen } from "reshow-unit";
import useConnect from "../useConnect.mjs";
import { jsx as _jsx } from "react/jsx-runtime";
describe("Test Connect hook for more test", function () {
  var reducer;
  beforeEach(function () {
    reducer = createReducer(function (state, action) {
      return action;
    }, {});
  });
  it("could register with store", /*#__PURE__*/_asyncToGenerator(function* () {
    var [store, dispatch] = reducer;

    var FakeComponent = function FakeComponent(props) {
      var state = useConnect({
        storeLocator: function storeLocator() {
          return store;
        },
        calculateState: function calculateState(prevState, props) {
          return {
            foo: store.getState().foo
          };
        }
      })(props);
      return /*#__PURE__*/_jsx("div", {
        role: "udom",
        children: state.foo
      });
    };

    render( /*#__PURE__*/_jsx(FakeComponent, {}));
    yield act(function () {
      return dispatch({
        foo: "bar"
      });
    }, 5);
    expect(screen().getByRole("udom").outerHTML).to.equal("<div role=\"udom\">bar</div>");
  }));
  it("could work with dispatcher", /*#__PURE__*/_asyncToGenerator(function* () {
    var _FakeComponent;

    var calculateTimes = 0;
    var wrap;
    var [store, dispatch] = reducer;

    var FakeComponent = function FakeComponent(props) {
      var state;
      state = useConnect({
        storeLocator: function storeLocator() {
          return store;
        },
        calculateState: function calculateState(prevState, props) {
          var state = store.getState();
          calculateTimes++;
          return {
            aaa: state.aaa
          };
        }
      })(props);
      return /*#__PURE__*/_jsx("div", {
        role: "udom",
        children: state.aaa
      });
    };

    expect(calculateTimes).to.equal(0);
    yield act(function () {
      return wrap = render(_FakeComponent || (_FakeComponent = /*#__PURE__*/_jsx(FakeComponent, {})));
    });
    expect(calculateTimes >= 2).to.be.true; //init and handlchange

    yield act(function () {
      dispatch({
        aaa: "Hello dispatcher!"
      });
    }, 5);
    var dispatchCalculateTimes = calculateTimes;
    expect(dispatchCalculateTimes >= 3).to.be.true;
    expect(screen().getByRole("udom").outerHTML).to.equal("<div role=\"udom\">Hello dispatcher!</div>");
    yield act(function () {
      return wrap.unmount();
    });
    dispatch({
      aaa: "Hello Unmount!"
    });
    expect(calculateTimes).to.equal(dispatchCalculateTimes);
  }));
  it("could work withProps", /*#__PURE__*/_asyncToGenerator(function* () {
    var getStoresProps = null;
    var calculateStateProps = null;
    var [store, dispatch] = reducer;

    var FakeComponent = function FakeComponent(props) {
      var state = useConnect({
        storeLocator: function storeLocator(props) {
          getStoresProps = props;
          return store;
        },
        calculateState: function calculateState(prevState, props) {
          calculateStateProps = _objectSpread({}, props);
          return {
            foo: props.foo
          };
        }
      })(props);
      return /*#__PURE__*/_jsx("div", {
        role: "udom",
        children: state.foo
      });
    };

    var changeFoo;

    var Parent = /*#__PURE__*/function (_Component) {
      _inherits(Parent, _Component);

      var _super = _createSuper(Parent);

      function Parent(props) {
        var _this;

        _classCallCheck(this, Parent);

        _this = _super.call(this, props);

        _defineProperty(_assertThisInitialized(_this), "state", {});

        changeFoo = function changeFoo(v) {
          _this.setState({
            foo: v
          });
        };

        return _this;
      }

      _createClass(Parent, [{
        key: "render",
        value: function render() {
          var foo = null;

          if (this.state && this.state.foo) {
            foo = this.state.foo;
          }

          return /*#__PURE__*/_jsx(FakeComponent, {
            foo: foo,
            renewProps: true
          });
        }
      }]);

      return Parent;
    }(Component);

    render( /*#__PURE__*/_jsx(Parent, {}));
    expect(getStoresProps).to.deep.include({
      foo: null
    });
    expect(calculateStateProps).to.deep.include({
      foo: null
    });
    yield act(function () {
      return changeFoo("bar");
    });
    expect(screen().getByRole("udom").outerHTML).to.equal("<div role=\"udom\">bar</div>");
    expect(getStoresProps).to.deep.include({
      foo: "bar"
    });
    expect(calculateStateProps).to.deep.include({
      foo: "bar"
    });
  }));
  it("could work with empty calculateState", function () {
    var [store, dispatch] = reducer;

    var FakeComponent = function FakeComponent(props) {
      var state = useConnect({
        storeLocator: function storeLocator() {
          return store;
        },
        calculateState: function calculateState(prevState, props) {}
      })(props);
      return /*#__PURE__*/_jsx("div", {
        role: "udom",
        "data-foo": state.foo,
        "data-bar": props.bar
      });
    };

    render( /*#__PURE__*/_jsx(FakeComponent, {
      bar: "bbb"
    }));
    expect(screen().getByRole("udom").outerHTML).to.equal("<div role=\"udom\" data-bar=\"bbb\"></div>");
  });
});