import { expect } from "chai";
import { ImmutableStore, Map, mergeMap, fromJS } from "reshow-flux";
import options from "../connectOptions.mjs";
var {
  calculateState
} = options;
describe("Test calculateState", function () {
  var pageStore;
  beforeEach(function () {
    var [store, dispatch] = ImmutableStore(function (state, action) {
      switch (action.type) {
        case "config/reset":
          return mergeMap(state.clear(), action.params);

        default:
          if (Object.keys(action)) {
            return mergeMap(state, action);
          } else {
            return state;
          }

      }
    });
    dispatch("config/reset", fromJS({
      foo: {
        bar: {
          foo1: "bar1"
        }
      }
    }));
    pageStore = store;
  });
  it("path data with immutable", function () {
    var actual = calculateState({}, {
      initStates: ["foo"],
      pathStates: {
        bar: ["foo", "bar"]
      },
      immutable: true,
      store: pageStore
    });
    expect(actual.bar instanceof Map).to.be.true;
  });
  it("path data with immutable not exits", function () {
    var acture = calculateState({}, {
      pathStates: {
        bar: ["foo", "bar"]
      },
      immutable: true,
      store: pageStore
    });
    expect(acture.bar).to.be.undefined;
  });
  it("path data with non immutable", function () {
    var acture = calculateState({}, {
      initStates: ["foo"],
      pathStates: {
        bar: ["foo", "bar"]
      },
      store: pageStore
    });
    expect(acture.bar).to.deep.equal({
      foo1: "bar1"
    });
  });
});