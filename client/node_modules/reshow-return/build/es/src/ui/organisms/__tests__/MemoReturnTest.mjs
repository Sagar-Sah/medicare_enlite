import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _asyncToGenerator from "reshow-runtime/es/helpers/asyncToGenerator";
import { useState } from "react";
import { expect } from "chai";
import { act, render, getSinon as sinon } from "reshow-unit";
import MemoReturn from "../MemoReturn.mjs";
import build from "reshow-build";
import { jsx as _jsx } from "react/jsx-runtime";
describe("Test MemoReturn", function () {
  it("basic test", function () {
    var Comp = function Comp(props) {
      return /*#__PURE__*/_jsx(MemoReturn, {
        children: function children() {
          return "div";
        }
      });
    };

    var wrap = render( /*#__PURE__*/_jsx(Comp, {}));
    expect(wrap.html()).to.equal("<div></div>");
  });
  it("render times test (function)", /*#__PURE__*/_asyncToGenerator(function* () {
    var spy1 = sinon().spy(function () {});
    var spy2 = sinon().spy(function () {
      return "div";
    });
    var gSet;

    var Comp = function Comp(props) {
      var [state, setState] = useState({});
      gSet = setState;
      spy1();
      return /*#__PURE__*/_jsx(MemoReturn, {
        props: state.props,
        children: function children() {
          return spy2();
        }
      });
    };

    var wrap = render( /*#__PURE__*/_jsx(Comp, {}));
    var count1;
    var count2;
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    expect(count1 === count2).to.be.true;
    yield act(function () {
      return gSet({
        foo: "bar"
      });
    });
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    expect(count1 > count2, "1").to.be.true;
    yield act(function () {
      return gSet({
        props: {}
      });
    });
    expect(count2 < spy2.callCount, "2").to.be.true;
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    yield act(function () {
      return gSet(function (prev) {
        return _objectSpread(_objectSpread({}, prev), {}, {
          foo: "bar",
          props: {}
        });
      });
    });
    expect(count2 < spy2.callCount, "3").to.be.true;
  }));
  it("render times test (children)", /*#__PURE__*/_asyncToGenerator(function* () {
    var spy1 = sinon().spy(function () {});
    var spy2 = sinon().spy(function () {
      return "div";
    });
    var gSet;

    var SubComp = function SubComp(props) {
      return /*#__PURE__*/_jsx(MemoReturn, {
        props: props.props,
        children: props.children
      });
    };

    var Comp = function Comp(props) {
      var [state, setState] = useState({});
      gSet = setState;
      spy1();
      return /*#__PURE__*/_jsx(SubComp, {
        props: state.props,
        children: spy2
      });
    };

    var wrap = render( /*#__PURE__*/_jsx(Comp, {}));
    var count1;
    var count2;
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    expect(count1 === count2).to.be.true;
    yield act(function () {
      return gSet({
        foo: "bar"
      });
    });
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    expect(count1 > count2, "1").to.be.true;
    yield act(function () {
      return gSet({
        props: {}
      });
    });
    expect(count2 < spy2.callCount, "2").to.be.true;
    count1 = spy1.callCount;
    count2 = spy2.callCount;
    yield act(function () {
      return gSet(function (prev) {
        return _objectSpread(_objectSpread({}, prev), {}, {
          foo: "bar",
          props: {}
        });
      });
    });
    expect(count2 < spy2.callCount, "3").to.be.true;
  }));
});